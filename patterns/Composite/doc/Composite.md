### Composite

组合——对象结构性模式。

#### 1、意图

将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

#### 2、动机

在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的组件创建复杂的图表。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为Text和Line这样的图元定义一些类，另外定义一些类作为这些图元的容器类。

然而这种方法存在一个问题：使得这些类的代码必须去吧对待图元对象和容器对象。而实际上大多数情况下它们是一样的。Composite模式描述了如何使用递归组合，使得用户不必对这些类进行区别。如下图所示：

![](/Users/moyee/ant-repo/github/designPatterns/patterns/Composite/doc/composite-demo.png)

Composite模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。在图形系统中这个类就是Graphic，它声明了一些与特定图形对象相关的操作，如draw。同时也声明了所有的组合对象共享的一些操作，如一些作用于访问和管理它的子部件。

Picture类定义了一个Graphic对象的聚合。Picture的draw操作是通过对它的子部件调用draw实现的，Picture还用这种方法实现了一些与其子部件相关的操作。由于Picture接口与Graphic接口是一致的，因此Picture对象可以递归地组合其他Picture对象。

下图是一个典型的由递归组合的Graphic对象组成的组合对象结构。

![](/Users/moyee/ant-repo/github/designPatterns/patterns/Composite/doc/tree-composite.png)

#### 3、适用性

以下情况使用Composite模式：

- 想表示对象的部分-整体层次结构；
- 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

#### 4、结构

![](/Users/moyee/ant-repo/github/designPatterns/patterns/Composite/doc/composite.png)

典型的Composite对象结构如下所示：

![](/Users/moyee/ant-repo/github/designPatterns/patterns/Composite/doc/a-composite.png)

#### 5、参与者

- Component（Graphic）：
  - 为组合中的对象声明接口；
  - 在适当的情况下，实现所有类共有接口的缺省行为；
  - 声明一个接口用于访问和管理Component的子组件；
  - （可选）在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。
- Leaf（Rectangle、Line等）：
  - 在组合中表示叶子节点对象，叶节点没有子节点；
  - 在组合中定义图元对象的行为。
- Composite（Picture）：
  - 定义有子部件的那些部件的行为；
  - 存储子部件；
  - 在Component接口中实现与子部件有关的操作。
- Client：通过Component接口操纵组合部件的对象。

#### 6、协作

- 用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前或之后可能执行一些辅助操作。

#### 7、效果

Composite模式：

- 定义了包含基本对象和组合对象的类层次结构：基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断递归下去；客户代码中，任何用到基本对象的地方都可以使用组合对象；
- 简化客户代码：客户可以一致地使用组合结构和单个对象，通常不需要知道处理的是一个叶节点还是组合组件；
- 使得更容易增加新类型的组件：新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起工作，程序不需要因新的Component类而改变；
- 使你的设计变得更加一般化：容易增加新组件也会产生一些问题，那就是很难限制组合中的组件。

#### 8、实现

我们在实现Composite模式时需要考虑以下几个问题：

1. 显式的父部件引用：保持从子部件的引用能简化组合结构的遍历和管理，父部件引用可以简化结构的上移和组件的删除，同时父部件引用也支持Chain of Responsibility模式；通常在Component类中定义父部件引用；对于父部件引用，必须维护一个不变式，即一个组合的所有子节点以这个组合为父节点，而反之该组合以这些节点为子节点。保证这一点最容易的办法是：仅当在一个组合中增加或删除一个组件时，才改变这个组件的父部件。
2. 共享组件：共享组件可以减少对存储的需求，但当一个组件只有一个父部件时，很难共享组件。一个可行的解决办法是为子部件存储多个父部件，但当一个请求在结构中向上传递时，这种方法会导致多义性，如果子部件可以将一些状态存储在外部，从而不需要向父部件发送请求，那么这种方法是可行的。
3. 最大化Component接口：Composite模式的目的之一是使得用户不知道它们正在使用的具体的Leaf和Composite类。为了达到这一目的，Composite类应为Leaf和Composite类尽可能多定义一些公共操作，然而，这样会与类层次结构设计原则相冲突，该原则规定：一个类只能定义那些对它的子类有意义的操作。
4. 声明管理子部件的操作：在Composite模式中一个重要的问题是在Composite类层次结构中哪一些类声明这些操作。详情参考110page。
5. Component是否应该实现一个Component列表：你可能希望在Component类中将子节点集合定义成一个实例变量，而这个Component类中也声明了一些操作对子节点进行访问和管理。但是在基类中存放子类指针，对叶节点来说会导致空间浪费，因为叶节点根本没有子节点，只有当该结构中子类数目相对较少时，才值得使用这种方法。
6. 子部件排序：如果需要考虑子节点的顺序时，必须仔细地设计对子节点的访问和管理接口，以便管理子节点序列，而组合语句就是这样一些Composite的实例。
7. 使用高速缓冲存储改善性能：如果需要对组合进行频繁的遍历或查找，Composite类可以缓冲存储对它的子节点进行遍历或查找的相关信息。
8. 应该由谁删除Component：当一个Composite被销毁时，通常最好由Composite负责删除其子节点。
9. 存储组件最好用哪一种数据结构：Composite可使用多种数据结构存储它们的子节点，包括列表、树、数组和hash表，数据结构的选择取决于效率。