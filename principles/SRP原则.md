### SRP原则

每一个模块或类所对应的职责，应对系统若干功能中的某个单一部分，同时关于该职责的封装都应当通过这个类来完成。

一个类或模块应当用于单一的，并且唯一的缘由被更改。

我们从以下三个角度来理解：

- Single：单一；
- Responsibility：职责；
- Change：改变。

#### 单一

单一意味着某些工作是独立的。

```
class UserComponent { 
  // 这是第一件事情，获取用户详情数据
  getUserInfo(id) {
    this.api.getUserInfo(id).then(saveToState)
  }

  // 这是第二件事情，渲染视图的逻辑
  render() {
    const { userInfo } = this.state;
    return <div>
      <ul>
        <li>Name: { userInfo.name }</li>
        <li>Surname: { userInfo.surname }</li>
        <li>Email: { userInfo.email }</li>
      </ul>
    </div>
  }
}
```

上面的代码，在一些小型应用中，问题倒不大，但可以有优化的空间：将关于用户详细数据的逻辑提升到调用层，上面的例子中，使用`this.props.data`来接受用户详情数据，`UserComponent`组件不再与获取用户详情的逻辑耦合，从而变得单一。

总之，不要让你的对象成为上帝对象。

上帝对象：一个知道一切事情，完成一切事情的对象。

#### 职责

职责指软件系统中，每一个指派给特定方法、类、包和模块所完成的工作或动作。

太多的职责导致耦合。

耦合性代表一个系统中某个部分对系统中另一部分的了解程度。

为了使一个系统达到适当的耦合度，需要从以下三个方面调整：

- 组件的内聚性；
- 如何测量每个组件的预期任务；
- 组件如何专注于任务本身。

#### 变更

变更指已经存在代码的修改或改变。

什么原因迫使我们需要对源码进行变更呢？

- 增加新功能；
- 修复缺陷或BUG；
- 重构代码以适配将来做出的变更。

#### 如何才能使代码切近单一职责原则

使代码保持足够简单。

将由于相同原因做出改变的东西聚集在一起，将由于不同原因而做出改变的东西彼此分离。

- 孤立变化；
- 追踪依赖：使用DI机制动态注入；
- 追踪方法参数：尽可能使方法保持简单；
- 尽早重构：按设计模式重构代码；
- 善于做出改变：保持事情的简单性，但不是一味追求简单。



